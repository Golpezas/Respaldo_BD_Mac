/**
 * @fileoverview Script para generar reportes semanales de pozos y sitios a partir de respuestas de formulario en Google Sheets.
 * 
 * Descripción general:
 * - Lee datos de una hoja de cálculo específica.
 * - Procesa TODAS las entradas en orden cronológico (por fecha y hora), sin filtrar por únicas o semanales.
 * - Genera documentos Google Docs con estructura formateada profesional y clara: 
 *   - Título con ID.
 *   - Detalles en párrafos simples (formato: "Campo: Valor").
 *   - No incluye Nombre y Apellido ni Legajo.
 *   - Descripción como párrafo separado fuera de cualquier cuadro.
 *   - Imágenes (frontal y adicional 1) en una tabla horizontal de 2 columnas, con tamaños ajustados para caber en una página.
 *   - Campos adicionales como urgencia, vandalismo si aplica.
 *   - Todo diseñado para caber en una página por entrada, con page break al final.
 * - Maneja procesamiento por lotes para evitar timeouts.
 * - Verifica tamaño de documento para pozos y sitios (máx 400 MB) y crea continuaciones si es necesario.
 * - Funciones independientes para pozos, sitios o ambos.
 * - Usa propiedades de script para persistir progreso y IDs de documentos.
 * - Incluye todos los campos relevantes de la hoja de cálculo.
 * - Maneja distinción entre tipos de informe (Vandalismo/Recorrido) mostrando campos condicionales.
 * - Logs extensos para depuración: inicio/fin de procesos, por cada entrada, inserción de imágenes, errores, progreso.
 * - Función adicional para detener el proceso: detenerGeneracion().
 * 
 * Requisitos:
 * - Google Apps Script con acceso a Sheets, Docs y Drive.
 * - Hoja de cálculo con encabezados específicos (REQUIRED_HEADERS).
 * - Carpeta 'Reportes semanales' en Drive.
 * 
 * Instrucciones de uso:
 * - Ejecutar GenerarReportesAYSA() para ambos.
 * - GenerarReportePozos() para solo pozos.
 * - GenerarReporteSitios() para solo sitios.
 * - Limpiar propiedades con limpiarPropiedades() si es necesario.
 * - Detener proceso con detenerGeneracion().
 * 
 * Autor: Grok (basado en código original y versiones previas del usuario).
 * Fecha: 13 de noviembre de 2025.
 */

// =============================================================================
// CONFIGURACIÓN GLOBAL
// =============================================================================

/** Tamaño máximo del documento (400 MB en bytes) para pozos y sitios. */
const MAX_DOC_SIZE_BYTES = 400 * 1024 * 1024;

/** Tamaño de lote para procesamiento (evita timeouts). */
const BATCH_SIZE = 5;

/** Servicio para propiedades persistentes. */
const SCRIPT_PROPERTIES = PropertiesService.getScriptProperties();

/** Zona horaria para fechas. */
const TIME_ZONE = "America/Argentina/Buenos_Aires";

/** Nombre de la hoja de cálculo fuente. */
const SHEET_NAME = 'Respuestas de formulario 1';

/** ID de la hoja de cálculo (reemplazar con el ID real si no es el activo). */
const SPREADSHEET_ID = SpreadsheetApp.getActiveSpreadsheet().getId(); // Usa el activo por defecto

/** Nombre de la carpeta en Drive para reportes. */
const FOLDER_NAME = 'Reportes semanales';

/** Encabezados requeridos en la hoja de cálculo. */
const REQUIRED_HEADERS = [
  "Marca temporal", "Fecha", "Hora", "Móvil / Acude", "Nombre y Apellido", "Legajo",
  "Tipo de Informe",
  "ID Pozo (Vandalismo)", "Tipos de Vandalismo Pozo", "Descripción de Vandalismo Pozo", "Foto Vandalismo Pozo", "Vandalismo Pozo Atendido",
  "ID Sitio (Vandalismo)", "Tipos de Vandalismo Sitio", "Descripción de Vandalismo Sitio", "Foto Vandalismo Sitio", "Vandalismo Sitio Atendido",
  "ID Pozo (Recorrido)", "Foto Frontal Pozo", "Descripción General", "Foto Adicional 1 Pozo", "Foto Adicional 2 Pozo", "Foto Adicional 3 Pozo",
  "Urgente (Pozo)", "Descripción de la Urgencia Pozo", "Urgencia Pozo Atendida",
  "ID Sitio (Recorrido)", "Foto Frontal Sitio", "Descripción General Sitio", "Foto Adicional 1 Sitio", "Foto Adicional 2 Sitio", "Foto Adicional 3 Sitio",
  "Urgente (Sitio)", "Descripción de la Urgencia Sitio", "Urgencia Sitio Atendida",
  "Servicio Eléctrico Pozo", "Servicio Eléctrico Sitio"
];

// =============================================================================
// FUNCIONES AUXILIARES
// =============================================================================

/**
 * Valida si un documento Google Doc existe y es accesible.
 * @param {string} docId - ID del documento.
 * @return {boolean} True si es válido.
 */
function isDocumentValid(docId) {
  if (!docId) return false;
  try {
    DocumentApp.openById(docId);
    Logger.log(`Documento válido: ${docId}`);
    return true;
  } catch (e) {
    Logger.log(`Documento no válido o sin acceso (ID: ${docId}): ${e.message}`);
    return false;
  }
}

/**
 * Busca un documento por prefijo de nombre en la carpeta.
 * @param {Folder} folder - Carpeta de Drive.
 * @param {string} namePrefix - Prefijo del nombre.
 * @return {string|null} ID del documento o null.
 */
function findDocumentByName(folder, namePrefix) {
  const dateStr = Utilities.formatDate(new Date(), TIME_ZONE, "dd-MM-yyyy");
  const expectedName = `${namePrefix} - ${dateStr}`;
  const files = folder.getFilesByName(expectedName);
  if (files.hasNext()) {
    const file = files.next();
    Logger.log(`Documento encontrado: ${expectedName} (ID: ${file.getId()})`);
    return file.getId();
  }
  Logger.log(`No se encontró documento: ${expectedName}`);
  return null;
}

/**
 * Obtiene o crea la carpeta en Drive.
 * @return {Folder} La carpeta.
 */
function getOrCreateFolder() {
  const folders = DriveApp.getFoldersByName(FOLDER_NAME);
  if (folders.hasNext()) {
    const folder = folders.next();
    Logger.log(`Carpeta '${FOLDER_NAME}' encontrada: ${folder.getId()}`);
    return folder;
  } else {
    const folder = DriveApp.createFolder(FOLDER_NAME);
    Logger.log(`Carpeta '${FOLDER_NAME}' creada: ${folder.getId()}`);
    return folder;
  }
}

/**
 * Ordena las filas por fecha y hora.
 * @param {Array<Array>} rows - Filas de datos.
 * @param {number} colFecha - Columna de fecha.
 * @param {number} colHora - Columna de hora.
 * @return {Array<Array>} Filas ordenadas.
 */
function ordenarPorFechaHora(rows, colFecha, colHora) {
  return rows.sort((a, b) => {
    const dateA = new Date(`${a[colFecha]} ${a[colHora]}`);
    const dateB = new Date(`${b[colFecha]} ${b[colHora]}`);
    return dateA - dateB;
  });
}

/**
 * Crea un trigger para continuar un tipo específico.
 * @param {string} tipo - "Pozo" o "Sitio".
 */
function crearTriggerParaTipo(tipo) {
  eliminarTriggers();
  const handler = tipo === "Pozo" ? "GenerarReportePozos" : "GenerarReporteSitios";
  ScriptApp.newTrigger(handler)
    .timeBased()
    .after(30 * 1000)
    .create();
  Logger.log(`Trigger creado para continuar ${tipo}`);
}

/**
 * Elimina todos los triggers relacionados.
 */
function eliminarTriggers() {
  ScriptApp.getProjectTriggers().forEach(trigger => {
    const handler = trigger.getHandlerFunction();
    if (['GenerarReportesAYSA', 'GenerarReportePozos', 'GenerarReporteSitios'].includes(handler)) {
      ScriptApp.deleteTrigger(trigger);
      Logger.log(`Trigger eliminado: ${handler}`);
    }
  });
}

/**
 * Limpia todas las propiedades de script.
 */
function limpiarPropiedades() {
  SCRIPT_PROPERTIES.deleteAllProperties();
  Logger.log("Todas las propiedades limpiadas");
}

/**
 * Detiene el proceso de generación: elimina triggers y limpia propiedades.
 */
function detenerGeneracion() {
  eliminarTriggers();
  SCRIPT_PROPERTIES.deleteProperty('continuationNumberPozo');
  SCRIPT_PROPERTIES.deleteProperty('continuationNumberSitio');
  limpiarPropiedades(); // Opcional: borra todo
  Logger.log("Proceso de generación detenido y contadores limpiados.");
  SpreadsheetApp.getUi().alert("Proceso de generación detenido.");
}

/**
 * Extrae ID de archivo de una URL de Drive.
 * @param {string} url - URL de la imagen.
 * @return {string|null} ID del archivo o null.
 */
function extractFileIdFromUrl(url) {
  const match = url.match(/id=([a-zA-Z0-9_-]+)/);
  if (match) {
    Logger.log(`ID extraído de URL: ${match[1]}`);
  } else {
    Logger.log(`No se pudo extraer ID de URL: ${url}`);
  }
  return match ? match[1] : null;
}

/**
 * Inserta una imagen en una celda de tabla si existe.
 * @param {TableCell} cell - Celda de la tabla.
 * @param {string} imageUrl - URL de la imagen.
 * @param {string} label - Etiqueta para error y log.
 * @return {boolean} True si se insertó la imagen.
 */
function insertImageInCell(cell, imageUrl, label) {
  if (!imageUrl || imageUrl.toString().trim() === "") {
    Logger.log(`No se proporcionó ${label}.`);
    cell.appendParagraph(`No se proporcionó ${label}.`).setAttributes({ 'ITALIC': true });
    return false;
  }
  try {
    const fileId = extractFileIdFromUrl(imageUrl);
    if (fileId) {
      const image = DriveApp.getFileById(fileId).getBlob();
      const insertedImage = cell.appendImage(image);
      insertedImage.setWidth(360).setHeight(360);
      cell.getChild(0).asParagraph().setAlignment(DocumentApp.HorizontalAlignment.CENTER);
      Logger.log(`${label} insertada exitosamente.`);
      return true;
    } else {
      Logger.log(`URL inválida para ${label}: ${imageUrl}`);
      cell.appendParagraph(`URL inválida para ${label}.`).setAttributes({ 'ITALIC': true, 'FOREGROUND_COLOR': '#FF0000' });
      return false;
    }
  } catch (e) {
    Logger.log(`Error al insertar ${label}: ${e.message}`);
    cell.appendParagraph(`Error al insertar ${label}: ${e.message}`).setAttributes({ 'ITALIC': true, 'FOREGROUND_COLOR': '#FF0000' });
    return false;
  }
}

// =============================================================================
// FUNCIONES DE GENERACIÓN DE REPORTES
// =============================================================================

/**
 * Abre o crea un documento con nombre esperado.
 * @param {string} docId - ID actual.
 * @param {string} namePrefix - Prefijo del nombre.
 * @return {Document} El documento.
 */
function openOrCreateDoc(docId, namePrefix) {
  try {
    const doc = DocumentApp.openById(docId);
    Logger.log(`Documento abierto: ${docId}`);
    return doc;
  } catch (e) {
    Logger.log(`Error al abrir documento (${docId}): ${e.message}. Creando nuevo...`);
    const folder = getOrCreateFolder();
    const dateStr = Utilities.formatDate(new Date(), TIME_ZONE, "dd-MM-yyyy");
    const doc = DocumentApp.create(`${namePrefix} - ${dateStr}`);
    docId = doc.getId();
    SCRIPT_PROPERTIES.setProperty(namePrefix.toLowerCase().includes('pozo') ? 'pozoDocId' : 'sitioDocId', docId);
    doc.getBody().appendParagraph(`${namePrefix} - ${dateStr}`).setHeading(DocumentApp.ParagraphHeading.HEADING1);
    DriveApp.getFileById(docId).moveTo(folder);
    Logger.log(`Nuevo documento creado: ${docId}`);
    return doc;
  }
}

/**
 * Añade datos al documento con manejo de tamaño para pozos y sitios.
 * @param {Array<Array>} batch - Batch de filas a procesar.
 * @param {Body} body - Cuerpo del documento.
 * @param {Object} colMap - Mapa de columnas.
 * @param {string} tipo - "Pozo" o "Sitio".
 */
function appendDataToDoc(batch, body, colMap, tipo) {
  const folder = getOrCreateFolder();
  let currentDocId = SCRIPT_PROPERTIES.getProperty(tipo === "Pozo" ? 'pozoDocId' : 'sitioDocId');
  let doc = DocumentApp.openById(currentDocId);
  body = doc.getBody();
  const contProp = `continuationNumber${tipo}`;
  let continuationNumber = parseInt(SCRIPT_PROPERTIES.getProperty(contProp) || '1');

  batch.forEach(row => {
    const file = DriveApp.getFileById(currentDocId);
    const size = file.getSize();
    Logger.log(`Tamaño actual del documento ${tipo} (${currentDocId}): ${size} bytes (~${(size / (1024*1024)).toFixed(2)} MB)`);

    // === VERIFICAR LÍMITE DE TAMAÑO ===
    if (size > MAX_DOC_SIZE_BYTES) {
      Logger.log(`Documento ${tipo} excede 400 MB. Creando continuación #${continuationNumber}...`);
      body.appendParagraph("LÍMITE DE TAMAÑO ALCANZADO (400 MB). Continuación en el siguiente archivo.")
        .setItalic(true)
        .setForegroundColor('#FF0000')
        .setFontSize(12);

      const dateStr = Utilities.formatDate(new Date(), TIME_ZONE, "dd-MM-yyyy");
      const baseName = tipo === "Pozo" ? "Reporte Semanal Pozos" : "Reporte Semanal Sitios";
      const newName = `${baseName} - Continuación ${continuationNumber} - ${dateStr}`;
      
      const newDoc = DocumentApp.create(newName);
      const newDocId = newDoc.getId();
      
      SCRIPT_PROPERTIES.setProperty(tipo === "Pozo" ? 'pozoDocId' : 'sitioDocId', newDocId);
      SCRIPT_PROPERTIES.setProperty(contProp, (continuationNumber + 1).toString());

      newDoc.getBody()
        .appendParagraph(newName)
        .setHeading(DocumentApp.ParagraphHeading.HEADING1)
        .setAlignment(DocumentApp.HorizontalAlignment.CENTER);
      
      newDoc.getBody()
        .appendParagraph("Continuación del reporte anterior (límite de 400 MB alcanzado).")
        .setItalic(true)
        .setForegroundColor('#0000FF')
        .setFontSize(11);

      DriveApp.getFileById(newDocId).moveTo(folder);
      Logger.log(`Nuevo documento de continuación creado: ${newDocId} (${newName})`);

      doc = newDoc;
      body = newDoc.getBody();
      currentDocId = newDocId;
    }

    // === PROCESAMIENTO DE CADA ENTRADA ===
    const idVand = tipo === "Pozo" ? row[colMap["ID Pozo (Vandalismo)"]] : row[colMap["ID Sitio (Vandalismo)"]];
    const idRec = tipo === "Pozo" ? row[colMap["ID Pozo (Recorrido)"]] : row[colMap["ID Sitio (Recorrido)"]];
    const id = idVand || idRec || "Sin ID";
    const esVandalismo = row[colMap["Tipo de Informe"]] === "Vandalismo";
    Logger.log(`Iniciando adición de datos para ${tipo} ID: ${id}`);

    body.appendParagraph(`${tipo} ID: ${id}`)
      .setHeading(DocumentApp.ParagraphHeading.HEADING2)
      .setBold(true);

    const fecha = Utilities.formatDate(row[colMap["Fecha"]], TIME_ZONE, "dd/MM/yyyy") || "No especificado";
    const hora = Utilities.formatDate(row[colMap["Hora"]], TIME_ZONE, "HH:mm") || "No especificado";
    body.appendParagraph(`Fecha y Hora: ${fecha} - ${hora}`);
    body.appendParagraph(`Móvil / Acude: ${row[colMap["Móvil / Acude"]] || "No especificado"}`);
    body.appendParagraph(`Tipo de Informe: ${row[colMap["Tipo de Informe"]] || "No especificado"}`);
    body.appendParagraph(`Servicio Eléctrico: ${row[colMap[`Servicio Eléctrico ${tipo}`]] || "No especificado"}`);

    const urgenteCol = colMap[`Urgente (${tipo})`];
    const descUrgCol = colMap[`Descripción de la Urgencia ${tipo}`];
    const atendUrgCol = colMap[`Urgencia ${tipo} Atendida`];
    const urgenciaText = row[urgenteCol] === "Sí" 
      ? `Sí - Descripción: ${row[descUrgCol] || "No especificada"} - Atendida: ${row[atendUrgCol] || "No especificado"}` 
      : "No";
    body.appendParagraph(`Urgencia: ${urgenciaText}`);

    let descripcion = "";
    if (esVandalismo) {
      const tiposVandCol = colMap[`Tipos de Vandalismo ${tipo}`];
      const descVandCol = colMap[`Descripción de Vandalismo ${tipo}`];
      const atendVandCol = colMap[`Vandalismo ${tipo} Atendido`];
      body.appendParagraph(`Tipos de Vandalismo: ${row[tiposVandCol] || "No especificado"}`);
      body.appendParagraph(`Vandalismo Atendido: ${row[atendVandCol] || "No especificado"}`);
      descripcion = row[descVandCol] || "No especificado";
    } else {
      const descGenCol = tipo === "Pozo" ? colMap["Descripción General"] : colMap["Descripción General Sitio"];
      descripcion = row[descGenCol] || "No especificado";
    }

    body.appendParagraph("Descripción:")
      .setHeading(DocumentApp.ParagraphHeading.HEADING3)
      .setBold(true);
    body.appendParagraph(descripcion)
      .setFontSize(11)
      .setLineSpacing(1.15);

    body.appendParagraph(`Fotos ${tipo}:`)
      .setHeading(DocumentApp.ParagraphHeading.HEADING3)
      .setBold(true);

    const imageTable = body.appendTable();
    imageTable.setBorderWidth(0);
    const imageRow = imageTable.appendTableRow();

    const fotoFrontalCol = colMap[`Foto Frontal ${tipo}`];
    const cellFrontal = imageRow.appendTableCell();
    insertImageInCell(cellFrontal, row[fotoFrontalCol], "foto frontal");

    const fotoAd1Col = colMap[`Foto Adicional 1 ${tipo}`];
    const cellAd1 = imageRow.appendTableCell();
    insertImageInCell(cellAd1, row[fotoAd1Col], "foto adicional 1");

    if (esVandalismo) {
      body.appendParagraph(`Foto de Vandalismo ${tipo}:`)
        .setHeading(DocumentApp.ParagraphHeading.HEADING3)
        .setBold(true);
      const vandImageTable = body.appendTable();
      vandImageTable.setBorderWidth(0);
      const vandRow = vandImageTable.appendTableRow();
      const vandCell = vandRow.appendTableCell();
      const fotoVandCol = colMap[`Foto Vandalismo ${tipo}`];
      insertImageInCell(vandCell, row[fotoVandCol], "foto de vandalismo");
    }

    body.appendHorizontalRule();
    body.appendPageBreak();
    Logger.log(`Adición completada para ${tipo} ID: ${id}`);
  });
}

/**
 * Función principal para generar reportes de pozos y sitios (general).
 */
function GenerarReportesAYSA() {
  Logger.log("Iniciando GenerarReportesAYSA - " + new Date().toLocaleString("es-AR", { timeZone: TIME_ZONE }));

  const folder = getOrCreateFolder();
  let pozoDocId = SCRIPT_PROPERTIES.getProperty('pozoDocId');
  let sitioDocId = SCRIPT_PROPERTIES.getProperty('sitioDocId');

  if (!isDocumentValid(pozoDocId)) {
    pozoDocId = findDocumentByName(folder, "Reporte Semanal Pozos") || createNewDoc(folder, "Reporte Semanal Pozos");
    SCRIPT_PROPERTIES.setProperty('pozoDocId', pozoDocId);
    SCRIPT_PROPERTIES.deleteProperty('lastProcessedPozo');
    SCRIPT_PROPERTIES.deleteProperty('continuationNumberPozo');
  }

  if (!isDocumentValid(sitioDocId)) {
    sitioDocId = findDocumentByName(folder, "Reporte Semanal Sitios") || createNewDoc(folder, "Reporte Semanal Sitios");
    SCRIPT_PROPERTIES.setProperty('sitioDocId', sitioDocId);
    SCRIPT_PROPERTIES.deleteProperty('lastProcessedSitio');
    SCRIPT_PROPERTIES.deleteProperty('continuationNumberSitio');
  }

  const { colMap, rows } = getDataAndColMap();

  const lastProcessedPozo = parseInt(SCRIPT_PROPERTIES.getProperty('lastProcessedPozo') || '0');
  const lastProcessedSitio = parseInt(SCRIPT_PROPERTIES.getProperty('lastProcessedSitio') || '0');

  const pozoRows = rows.filter(row => row[colMap["ID Pozo (Vandalismo)"]] || row[colMap["ID Pozo (Recorrido)"]]);
  const sitioRows = rows.filter(row => row[colMap["ID Sitio (Vandalismo)"]] || row[colMap["ID Sitio (Recorrido)"]]);

  const pozoStatus = processReportType(pozoRows, colMap, pozoDocId, lastProcessedPozo, "Pozo");
  const sitioStatus = processReportType(sitioRows, colMap, sitioDocId, lastProcessedSitio, "Sitio");

  if (pozoStatus.hasMore || sitioStatus.hasMore) {
    crearTrigger();
    SpreadsheetApp.getUi().alert("Procesamiento en curso. Se generarán más datos en la próxima ejecución.");
  } else {
    eliminarTriggers();
    SpreadsheetApp.getUi().alert("Reportes generados con éxito en la carpeta 'Reportes semanales' en Google Drive.");
  }
}

/**
 * Genera reporte solo para pozos.
 */
function GenerarReportePozos() {
  Logger.log("=== INICIANDO REPORTE SOLO POZOS ===");
  const tipo = "Pozo";
  const docIdProp = "pozoDocId";
  const lastProcessedProp = "lastProcessedPozo";
  const nombreBase = "Reporte Semanal Pozos";

  const folder = getOrCreateFolder();
  let docId = SCRIPT_PROPERTIES.getProperty(docIdProp);
  let isNewDoc = false;

  if (!docId || !isDocumentValid(docId)) {
    docId = findDocumentByName(folder, nombreBase);
    if (!docId) {
      docId = createNewDoc(folder, nombreBase);
      isNewDoc = true;
    } else {
      SCRIPT_PROPERTIES.setProperty(docIdProp, docId);
    }
  } else {
    const file = DriveApp.getFileById(docId);
    const expectedName = `${nombreBase} - ${Utilities.formatDate(new Date(), TIME_ZONE, "dd-MM-yyyy")}`;
    if (file.getName() !== expectedName) {
      docId = createNewDoc(folder, nombreBase);
      isNewDoc = true;
    }
  }

  if (isNewDoc) {
    SCRIPT_PROPERTIES.deleteProperty(lastProcessedProp);
    SCRIPT_PROPERTIES.deleteProperty('continuationNumberPozo');
    Logger.log('Progreso y contador de continuación reiniciados para pozos.');
  }

  const { colMap, rows } = getDataAndColMap(true, tipo);
  const lastProcessed = parseInt(SCRIPT_PROPERTIES.getProperty(lastProcessedProp) || '0');
  const status = processReportType(rows, colMap, docId, lastProcessed, tipo);

  if (status.hasMore) {
    crearTriggerParaTipo(tipo);
  } else {
    eliminarTriggers();
    Logger.log(`Reporte de ${tipo}s completado.`);
  }
}

/**
 * Genera reporte solo para sitios.
 */
function GenerarReporteSitios() {
  Logger.log("=== INICIANDO REPORTE SOLO SITIOS ===");
  const tipo = "Sitio";
  const docIdProp = "sitioDocId";
  const lastProcessedProp = "lastProcessedSitio";
  const nombreBase = "Reporte Semanal Sitios";

  const folder = getOrCreateFolder();
  let docId = SCRIPT_PROPERTIES.getProperty(docIdProp);
  let isNewDoc = false;

  if (!docId || !isDocumentValid(docId)) {
    docId = findDocumentByName(folder, nombreBase);
    if (!docId) {
      docId = createNewDoc(folder, nombreBase);
      isNewDoc = true;
    } else {
      SCRIPT_PROPERTIES.setProperty(docIdProp, docId);
    }
  } else {
    const file = DriveApp.getFileById(docId);
    const expectedName = `${nombreBase} - ${Utilities.formatDate(new Date(), TIME_ZONE, "dd-MM-yyyy")}`;
    if (file.getName() !== expectedName) {
      docId = createNewDoc(folder, nombreBase);
      isNewDoc = true;
    }
  }

  if (isNewDoc) {
    SCRIPT_PROPERTIES.deleteProperty(lastProcessedProp);
    SCRIPT_PROPERTIES.deleteProperty('continuationNumberSitio');
    Logger.log('Progreso y contador de continuación reiniciados para sitios.');
  }

  const { colMap, rows } = getDataAndColMap(true, tipo);
  const lastProcessed = parseInt(SCRIPT_PROPERTIES.getProperty(lastProcessedProp) || '0');
  const status = processReportType(rows, colMap, docId, lastProcessed, tipo);

  if (status.hasMore) {
    crearTriggerParaTipo(tipo);
  } else {
    eliminarTriggers();
    Logger.log(`Reporte de ${tipo}s completado.`);
  }
}

/**
 * Crea un nuevo documento y lo mueve a la carpeta.
 * @param {Folder} folder - Carpeta de Drive.
 * @param {string} namePrefix - Prefijo del nombre.
 * @return {string} ID del nuevo documento.
 */
function createNewDoc(folder, namePrefix) {
  const dateStr = Utilities.formatDate(new Date(), TIME_ZONE, "dd-MM-yyyy");
  const doc = DocumentApp.create(`${namePrefix} - ${dateStr}`);
  const docId = doc.getId();
  SCRIPT_PROPERTIES.setProperty(namePrefix.toLowerCase().includes('pozo') ? 'pozoDocId' : 'sitioDocId', docId);
  doc.getBody().appendParagraph(`${namePrefix} - ${dateStr}`).setHeading(DocumentApp.ParagraphHeading.HEADING1);
  DriveApp.getFileById(docId).moveTo(folder);
  Logger.log(`Nuevo documento creado y movido: ${docId}`);
  return docId;
}

/**
 * Obtiene mapa de columnas y datos filtrados/ordenados.
 * @param {boolean} [filterByType=false] - Si filtrar por tipo.
 * @param {string} [tipo] - Tipo para filtrar.
 * @return {Object} {colMap, rows}.
 */
function getDataAndColMap(filterByType = false, tipo = null) {
  Logger.log('Iniciando obtención de datos y mapa de columnas.');
  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = spreadsheet.getSheetByName(SHEET_NAME);
  if (!sheet) throw new Error(`Hoja '${SHEET_NAME}' no encontrada`);

  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) throw new Error("No hay datos en la hoja");

  const headers = data[0];
  const colMap = {};
  headers.forEach((h, i) => colMap[h] = i);

  REQUIRED_HEADERS.forEach(h => {
    if (colMap[h] === undefined) throw new Error(`Falta encabezado '${h}'`);
  });

  let rows = data.slice(1);
  rows = ordenarPorFechaHora(rows, colMap["Fecha"], colMap["Hora"]);
  Logger.log(`Filas ordenadas: ${rows.length}`);

  if (filterByType && tipo) {
    const idColsVand = tipo === "Pozo" ? colMap["ID Pozo (Vandalismo)"] : colMap["ID Sitio (Vandalismo)"];
    const idColsRec = tipo === "Pozo" ? colMap["ID Pozo (Recorrido)"] : colMap["ID Sitio (Recorrido)"];
    rows = rows.filter(row => row[idColsVand] || row[idColsRec]);
    Logger.log(`Filtradas ${rows.length} filas para ${tipo}`);
  }

  return { colMap, rows };
}

/**
 * Procesa un tipo de reporte (pozo o sitio).
 * @param {Array<Array>} rows - Filas filtradas.
 * @param {Object} colMap - Mapa de columnas.
 * @param {string} docId - ID del documento.
 * @param {number} lastProcessed - Índice procesado.
 * @param {string} tipo - "Pozo" o "Sitio".
 * @return {Object} {hasMore: boolean}.
 */
function processReportType(rows, colMap, docId, lastProcessed, tipo) {
  Logger.log(`Procesando ${tipo}: ${rows.length} filas, desde ${lastProcessed}`);
  if (rows.length === 0) return { hasMore: false };

  const batch = rows.slice(lastProcessed, lastProcessed + BATCH_SIZE);
  if (batch.length === 0) return { hasMore: false };

  const doc = openOrCreateDoc(docId, tipo === "Pozo" ? "Reporte Semanal Pozos" : "Reporte Semanal Sitios");
  const body = doc.getBody();
  appendDataToDoc(batch, body, colMap, tipo);

  const newLastProcessed = lastProcessed + batch.length;
  SCRIPT_PROPERTIES.setProperty(tipo === "Pozo" ? 'lastProcessedPozo' : 'lastProcessedSitio', newLastProcessed.toString());
  Logger.log(`Progreso ${tipo}: ${newLastProcessed}/${rows.length}`);

  return { hasMore: newLastProcessed < rows.length };
}

/**
 * Crea un trigger para continuar el procesamiento general.
 */
function crearTrigger() {
  eliminarTriggers();
  ScriptApp.newTrigger('GenerarReportesAYSA')
    .timeBased()
    .after(30 * 1000)
    .create();
  Logger.log("Trigger creado para continuar procesamiento general");
}